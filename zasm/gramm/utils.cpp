#include <stdarg.h>
#include <stdexcept>
#include <string.h>
#include <assert.h>
#include <ctype.h>

#if defined(_WIN32)
#include <windows.h>
#include <direct.h>
#include <mbstring.h>
#include <io.h>
#include <sys/stat.h>
#include <sys/types.h>
#define getcwd _getcwd
#define strdup _strdup
#define chdir _chdir
#define mkdir _mkdir
#define xstat _stat64
#else
#include <unistd.h>
#include <linux/limits.h>
#include <sys/stat.h>
#include <sys/types.h>
#define MAX_PATH PATH_MAX
#define _MAX_PATH PATH_MAX
#define xstat stat
#endif


//#include "../Error.h"
#include "utils.h"
#include "mempool.h"



	bool
		urlify_smth(const unsigned char *str, unsigned char *target, int64_t len)
	{
		int64_t filled = 0;
		char escape[6];
		escape[0] = '%';
		escape[3] = 0;

		const unsigned char *cptr = str;
		if (target)
		{
			for (; *cptr; cptr++)
			{
				if ((*cptr >= 'A' && *cptr <= 'Z') ||
					(*cptr >= 'a' && *cptr <= 'z') ||
					(*cptr >= '0' && *cptr <= '9') ||
					*cptr == '-' || *cptr == '_' || *cptr == '.' ||
					*cptr == '!' || *cptr == '~' || *cptr == '*' ||
					/* *cptr == '\''||*/ *cptr == '(' || *cptr == ')' ||
					(*cptr == '%' &&
					((cptr[1] >= 'A' && cptr[1] <= 'F') ||
						(cptr[1] >= 'a' && cptr[1] <= 'f') ||
						(cptr[1] >= '0' && cptr[1] <= '9')) &&
						((cptr[2] >= 'A' && cptr[2] <= 'F') ||
						(cptr[2] >= 'a' && cptr[2] <= 'f') ||
							(cptr[2] >= '0' && cptr[2] <= '9'))))
				{
					if (filled >= len)
						return false;
					*target++ = *cptr;
					filled++;
				}
				else
				{
					if ((*cptr >> 4) < 10)
						escape[1] = '0' + (*cptr >> 4);
					else
						escape[1] = 'A' - 10 + (*cptr >> 4);
					if ((*cptr & 0xF) < 10)
						escape[2] = '0' + (*cptr & 0xF);
					else
						escape[2] = 'A' - 10 + (*cptr & 0xF);

					if (filled >= len - 3)
						return false;
					*target++ = escape[0];
					*target++ = escape[1];
					*target++ = escape[2];
					filled += 3;
				}
			}
		}
		if (filled < len)
			*target++ = 0;
		return true;
	}

#define isoctdigit(C) (((C) & ~7) == 060)    /* 060 = 0x30 = 48. = '0' */
#define hexdigtoi(C) (isdigit(C) ? ((C) - '0') : (toupper(C) - ('A' - 10)))

	int parse_not_char_c_escape = 0;
	int64_t parse_string_literal(wchar_t **str_ptr, wchar_t *result, wchar_t bra)
	{
		unsigned int i = 0;
		unsigned int q, z;
		wchar_t *str = *str_ptr;
		const wchar_t beg_quote = bra;
		wchar_t c;
		int in_strlit = 0;

		for (/* no init*/; '\0' != str[0]; str++)
		{
			switch (*str)
			{
			case '\\':        /* An escaped character follows? */
			{
				assert(in_strlit);
				if (!parse_not_char_c_escape)
				{
					switch (*++str)    /* Check the next character. */
					{
						/* If a string anomalously ends with a trailing (single) backslash, then
						leave it dangling there: */
					case '\0':
					{
						c = *(str - 1);
						break;
					}
					case 'a':
					{
						c = '\7';
						break;
					}        /* BEL audible alert */
					case 'b':
					{
						c = '\b';
						break;
					}        /* BS  backspace */
							 /*          case 'e': { c = '\033'; break; } *//* ESC escape */
					case 'f':
					{
						c = '\f';
						break;
					}        /* FF  form feed */
					case 'n':
					{
						c = '\n';
						break;
					}        /* NL (LF) newline */
					case 'r':
					{
						c = '\r';
						break;
					}        /* CR  carriage return */
					case 't':
					{
						c = '\t';
						break;
					}        /* HT  horizontal tab */
					case 'v':
					{
						c = '\013';
						break;
					}        /* VT  vertical tab */
					case 'x':    /* There's a hexadecimal wchar_t constant \xhh */
					case 'X':
					{        /* We should check that only max 2 digits are parsed */
						q = 2;
						z = 0;
						str++;
						while (*str && isxdigit(*str) && (q--))
						{
							z = ((z << 4) +
								(isdigit(*str) ?
								(*str - '0') :
									(toupper(*str) - 'A' + 10)));
							str++;
						}
						c = wchar_t(z);
						str--;    /* str is incremented soon. */
						break;
					}
					case '0':
					case '1':
					case '2':
					case '3':
					case '4':
					case '5':
					case '6':
					case '7':
					{        /* So it's an octal sequence like \033 : */
						q = 3;
						z = 0;
						while (isoctdigit(*str) && (q--))
						{
							z = ((z << 3) + (*str++ - '0'));
						}
						c = wchar_t(z);
						str--;    /* str is incremented soon. */
						break;
					}        /* octal digits */
					case '\n':
					case '\r':
						continue;
					default:        /* Every other character after backslash produces */
					{        /* that same character, i.e. \\ = \, \' = ', etc. */
						c = *str;
						break;
					}        /* default */

					}            /* inner switch for character after a backslash */
					if (result)
						result[i] = c;
					i++;
					break;
				} /* if for processing escapes */
			}            /* case for backslash. */
			default:
			{
				if (*str == beg_quote)
				{
					in_strlit ^= 1;
					if (!in_strlit)
					{
						for (; *str;)
						{
							str++;
							if (*str == beg_quote)
								break;
							if (0 == *str || NULL == wcschr(L" \t\r\n", *str))
								goto out;
						}
						if (*str == beg_quote) {
							in_strlit ^= 1;
							assert(in_strlit);
							continue;
						}
					}
				}
				else
					/* Any other character. */
				{
					assert(in_strlit);
					if (result)
						result[i] = *str;
					i++;
					break;
				}
			}
			}            /* outer switch */
		}                /* for loop */
	out:;
		if (result)
		{
			result[i] = '\0';
		}                /* Put a terminating zero. */
		if (*str)            /* The terminating quote is here. */
		{
			*str_ptr = str + 1;    /* Skip past it. */
		}
		else
		{
			/* The terminating quote is missing, we should produce an error here! */
			*str_ptr = str;        /* But in this version we are tolerant of that. */
		}
		return (i);            /* Return the length. */
	}

	int64_t escape_sql_string_nl(const char *str, char*result, int64_t&result_len)
	{
		if (0 == result_len || NULL == str || NULL == result)
			return 0;
		int64_t max_res_len = result_len - 1;
		char *ptr = result;
		for (/* no init*/; '\0' != *str && (ptr - result) < max_res_len; str++)
		{
			switch (*str)
			{
			case '\\':
				*ptr++ = *str;
				if (str[1] == '\n')
					*ptr++ = *str++;
				break;
			case '\n':
				*ptr++ = '\\';
			default:
				*ptr++ = *str;
			}
		}
		*ptr = 0;
		return (ptr - result);
	}

	int64_t escape_string_literal(const wchar_t *str, wchar_t *result, int64_t&result_len)
	{
		if (0 == result_len || NULL == str || NULL == result)
			return 0;
		int64_t max_res_len = result_len - 1;
		wchar_t *ptr = result;
		for (/* no init*/; '\0' != *str && (ptr - result) < max_res_len; str++)
		{
			switch (*str)
			{
			case L'\\':
				*ptr++ = '\\';
				*ptr++ = '\\';
				break;
			case L'\n':
				*ptr++ = '\\';
				*ptr++ = 'n';
				break;
			case L'\r':
				*ptr++ = '\\';
				*ptr++ = 'r';
				break;
			case '\7':
				*ptr++ = '\\';
				*ptr++ = '7';
				break;
			case '\b':
				*ptr++ = '\\';
				*ptr++ = 'b';
				break;
			case '\f':
				*ptr++ = '\\';
				*ptr++ = 'f';
				break;
			case '\t':
				*ptr++ = '\\';
				*ptr++ = 't';
				break;
			case '\v':
				*ptr++ = '\\';
				*ptr++ = 'v';
				break;
			case '\'':
				*ptr++ = '\\';
				*ptr++ = '\'';
				break;
			case '\"':
				*ptr++ = '\\';
				*ptr++ = '\"';
				break;
			default:
				*ptr++ = *str;
			}
		}
		*ptr = 0;
		return (ptr - result);
	}
	
	int64_t escape_pg_string_literal(const wchar_t* str, wchar_t* result, int64_t& result_len)
	{
		if (0 == result_len || NULL == str || NULL == result)
			return 0;
		int64_t max_res_len = result_len - 1;
		wchar_t* ptr = result;
		for (/* no init*/; '\0' != *str && (ptr - result) < max_res_len; str++)
		{
			switch (*str)
			{
			case L'\\':
				*ptr++ = '\\';
				*ptr++ = '\\';
				break;
//			case L'\n':
//				*ptr++ = '\'';
//				*ptr++ = '\n';
//				*ptr++ = '\'';
//				break;
			case '\'':
				*ptr++ = '\'';
				*ptr++ = '\'';
				break;
//			case '\"':
//				*ptr++ = '\\';
//				*ptr++ = '\"';
//				break;
			default:
				*ptr++ = *str;
			}
		}
		*ptr = 0;
		return (ptr - result);
	}

	int64_t parse_pg_string_literal(const wchar_t* str, wchar_t* result, int64_t len, int64_t& result_len)
	{
		if (0 == result_len || NULL == str || NULL == result)
			return 0;
		int64_t max_res_len = result_len - 1;
		const wchar_t* str0 = str;
		wchar_t* ptr = result;
		for (/* no init*/; '\0' != *str && (ptr - result) < max_res_len && ((str - str0) < len); str++)
		{
			switch (*str)
			{
			case '\\':
				if ('\\' == str[1]) {
					*ptr++ = '\\';
					str++;
				} else
				*ptr++ = '\\';
				break;
			case '\'':
				if ('\'' == str[1]) {
					*ptr++ = '\'';
					str++;
				}
				else
					*ptr++ = '\'';
				break;
			default:
				*ptr++ = *str;
			}
		}
		*ptr = 0;
		return (ptr - result);
	}

	static const wchar_t cp866_to_ucode_cvrt_tab[256] = {
		   0x0000  , 0x0001  , 0x0002  , 0x0003  , 0x0004  , 0x0005  , 0x0006  , 0x0007
		 , 0x0008  , 0x0009  , 0x000a  , 0x000b  , 0x000c  , 0x000d  , 0x000e  , 0x000f
		 , 0x0010  , 0x0011  , 0x0012  , 0x0013  , 0x0014  , 0x0015  , 0x0016  , 0x0017
		 , 0x0018  , 0x0019  , 0x001a  , 0x001b  , 0x001c  , 0x001d  , 0x001e  , 0x001f
		 , 0x0020  , 0x0021  , 0x0022  , 0x0023  , 0x0024  , 0x0025  , 0x0026  , 0x0027
		 , 0x0028  , 0x0029  , 0x002a  , 0x002b  , 0x002c  , 0x002d  , 0x002e  , 0x002f
		 , 0x0030  , 0x0031  , 0x0032  , 0x0033  , 0x0034  , 0x0035  , 0x0036  , 0x0037
		 , 0x0038  , 0x0039  , 0x003a  , 0x003b  , 0x003c  , 0x003d  , 0x003e  , 0x003f
		 , 0x0040  , 0x0041  , 0x0042  , 0x0043  , 0x0044  , 0x0045  , 0x0046  , 0x0047
		 , 0x0048  , 0x0049  , 0x004a  , 0x004b  , 0x004c  , 0x004d  , 0x004e  , 0x004f
		 , 0x0050  , 0x0051  , 0x0052  , 0x0053  , 0x0054  , 0x0055  , 0x0056  , 0x0057
		 , 0x0058  , 0x0059  , 0x005a  , 0x005b  , 0x005c  , 0x005d  , 0x005e  , 0x005f
		 , 0x0060  , 0x0061  , 0x0062  , 0x0063  , 0x0064  , 0x0065  , 0x0066  , 0x0067
		 , 0x0068  , 0x0069  , 0x006a  , 0x006b  , 0x006c  , 0x006d  , 0x006e  , 0x006f
		 , 0x0070  , 0x0071  , 0x0072  , 0x0073  , 0x0074  , 0x0075  , 0x0076  , 0x0077
		 , 0x0078  , 0x0079  , 0x007a  , 0x007b  , 0x007c  , 0x007d  , 0x007e  , 0x007f
		 , 0x0410  , 0x0411  , 0x0412  , 0x0413  , 0x0414  , 0x0415  , 0x0416  , 0x0417
		 , 0x0418  , 0x0419  , 0x041a  , 0x041b  , 0x041c  , 0x041d  , 0x041e  , 0x041f
		 , 0x0420  , 0x0421  , 0x0422  , 0x0423  , 0x0424  , 0x0425  , 0x0426  , 0x0427
		 , 0x0428  , 0x0429  , 0x042a  , 0x042b  , 0x042c  , 0x042d  , 0x042e  , 0x042f
		 , 0x0430  , 0x0431  , 0x0432  , 0x0433  , 0x0434  , 0x0435  , 0x0436  , 0x0437
		 , 0x0438  , 0x0439  , 0x043a  , 0x043b  , 0x043c  , 0x043d  , 0x043e  , 0x043f
		 , 0x2591  , 0x2592  , 0x2593  , 0x2502  , 0x2524  , 0x2561  , 0x2562  , 0x2556
		 , 0x2555  , 0x2563  , 0x2551  , 0x2557  , 0x255d  , 0x255c  , 0x255b  , 0x2510
		 , 0x2514  , 0x2534  , 0x252c  , 0x251c  , 0x2500  , 0x253c  , 0x255e  , 0x255f
		 , 0x255a  , 0x2554  , 0x2569  , 0x2566  , 0x2560  , 0x2550  , 0x256c  , 0x2567
		 , 0x2568  , 0x2564  , 0x2565  , 0x2559  , 0x2558  , 0x2552  , 0x2553  , 0x256b
		 , 0x256a  , 0x2518  , 0x250c  , 0x2588  , 0x2584  , 0x258c  , 0x2590  , 0x2580
		 , 0x0440  , 0x0441  , 0x0442  , 0x0443  , 0x0444  , 0x0445  , 0x0446  , 0x0447
		 , 0x0448  , 0x0449  , 0x044a  , 0x044b  , 0x044c  , 0x044d  , 0x044e  , 0x044f
		 , 0x0401  , 0x0451  , 0x0404  , 0x0454  , 0x0407  , 0x0457  , 0x040e  , 0x045e
		 , 0x00b0  , 0x2219  , 0x00b7  , 0x221a  , 0x2116  , 0x00a4  , 0x25a0  , 0x00a0
	};
	int cp866_to_ucode(const char* src, wchar_t* dest, unsigned maxchars)
	{
		unsigned i;
		for (i = 0; *src && i < maxchars; i++)
		{
			dest[i] = cp866_to_ucode_cvrt_tab[(unsigned char)src[i]];
		}
		if (i < maxchars && 0 != dest[i])
			dest[i++] = 0;

		return i;
	}

	static const wchar_t cp1251_to_ucode_cvrt_tab[256] = {
		0x0000  , 0x0001  , 0x0002  , 0x0003  , 0x0004  , 0x0005  , 0x0006  , 0x0007
		, 0x0008  , 0x0009  , 0x000a  , 0x000b  , 0x000c  , 0x000d  , 0x000e  , 0x000f
		, 0x0010  , 0x0011  , 0x0012  , 0x0013  , 0x0014  , 0x0015  , 0x0016  , 0x0017
		, 0x0018  , 0x0019  , 0x001a  , 0x001b  , 0x001c  , 0x001d  , 0x001e  , 0x001f
		, 0x0020  , 0x0021  , 0x0022  , 0x0023  , 0x0024  , 0x0025  , 0x0026  , 0x0027
		, 0x0028  , 0x0029  , 0x002a  , 0x002b  , 0x002c  , 0x002d  , 0x002e  , 0x002f
		, 0x0030  , 0x0031  , 0x0032  , 0x0033  , 0x0034  , 0x0035  , 0x0036  , 0x0037
		, 0x0038  , 0x0039  , 0x003a  , 0x003b  , 0x003c  , 0x003d  , 0x003e  , 0x003f
		, 0x0040  , 0x0041  , 0x0042  , 0x0043  , 0x0044  , 0x0045  , 0x0046  , 0x0047
		, 0x0048  , 0x0049  , 0x004a  , 0x004b  , 0x004c  , 0x004d  , 0x004e  , 0x004f
		, 0x0050  , 0x0051  , 0x0052  , 0x0053  , 0x0054  , 0x0055  , 0x0056  , 0x0057
		, 0x0058  , 0x0059  , 0x005a  , 0x005b  , 0x005c  , 0x005d  , 0x005e  , 0x005f
		, 0x0060  , 0x0061  , 0x0062  , 0x0063  , 0x0064  , 0x0065  , 0x0066  , 0x0067
		, 0x0068  , 0x0069  , 0x006a  , 0x006b  , 0x006c  , 0x006d  , 0x006e  , 0x006f
		, 0x0070  , 0x0071  , 0x0072  , 0x0073  , 0x0074  , 0x0075  , 0x0076  , 0x0077
		, 0x0078  , 0x0079  , 0x007a  , 0x007b  , 0x007c  , 0x007d  , 0x007e  , 0x007f
		, 0x0402  , 0x0403  , 0x201a  , 0x0453  , 0x201e  , 0x2026  , 0x2020  , 0x2021
		, 0x20ac  , 0x2030  , 0x0409  , 0x2039  , 0x040a  , 0x040c  , 0x040b  , 0x040f
		, 0x0452  , 0x2018  , 0x2019  , 0x201c  , 0x201d  , 0x2022  , 0x2013  , 0x2014
		, 0x0098  , 0x2122  , 0x0459  , 0x203a  , 0x045a  , 0x045c  , 0x045b  , 0x045f
		, 0x00a0  , 0x040e  , 0x045e  , 0x0408  , 0x00a4  , 0x0490  , 0x00a6  , 0x00a7
		, 0x0401  , 0x00a9  , 0x0404  , 0x00ab  , 0x00ac  , 0x00ad  , 0x00ae  , 0x0407
		, 0x00b0  , 0x00b1  , 0x0406  , 0x0456  , 0x0491  , 0x00b5  , 0x00b6  , 0x00b7
		, 0x0451  , 0x2116  , 0x0454  , 0x00bb  , 0x0458  , 0x0405  , 0x0455  , 0x0457
		, 0x0410  , 0x0411  , 0x0412  , 0x0413  , 0x0414  , 0x0415  , 0x0416  , 0x0417
		, 0x0418  , 0x0419  , 0x041a  , 0x041b  , 0x041c  , 0x041d  , 0x041e  , 0x041f
		, 0x0420  , 0x0421  , 0x0422  , 0x0423  , 0x0424  , 0x0425  , 0x0426  , 0x0427
		, 0x0428  , 0x0429  , 0x042a  , 0x042b  , 0x042c  , 0x042d  , 0x042e  , 0x042f
		, 0x0430  , 0x0431  , 0x0432  , 0x0433  , 0x0434  , 0x0435  , 0x0436  , 0x0437
		, 0x0438  , 0x0439  , 0x043a  , 0x043b  , 0x043c  , 0x043d  , 0x043e  , 0x043f
		, 0x0440  , 0x0441  , 0x0442  , 0x0443  , 0x0444  , 0x0445  , 0x0446  , 0x0447
		, 0x0448  , 0x0449  , 0x044a  , 0x044b  , 0x044c  , 0x044d  , 0x044e  , 0x044f
	};

	int cp1251_to_ucode(const char *src, wchar_t *dest, unsigned maxchars)
	{
		unsigned i;
		for (i = 0; *src && i < maxchars; i++)
		{
			dest[i] = cp1251_to_ucode_cvrt_tab[(unsigned char)src[i]];
		}
		if (i < maxchars && 0 != dest[i])
			dest[i++] = 0;

		return i;
	}

	static unsigned char cp_utf8_to_1251_page_00[256] = {
		0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
		0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
		0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
		0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
		0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,
		0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
		0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,
		0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
		0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,
		0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,
		0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,
		0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,
		0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,
		0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
		0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,
		0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x98,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0xa0,0x3f,0x3f,0x3f,0xa4,0x3f,0xa6,0xa7,
		0x3f,0xa9,0x3f,0xab,0xac,0xad,0xae,0x3f,
		0xb0,0xb1,0x3f,0x3f,0x3f,0xb5,0xb6,0xb7,
		0x3f,0x3f,0x3f,0xbb,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
	};
	static unsigned char cp_utf8_to_1251_page_04[256] = {
		0x3f,0xa8,0x80,0x81,0xaa,0xbd,0xb2,0xaf,
		0xa3,0x8a,0x8c,0x8e,0x8d,0x3f,0xa1,0x8f,
		0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,
		0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,
		0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,
		0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,
		0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,
		0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,
		0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,
		0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff,
		0x3f,0xb8,0x90,0x83,0xba,0xbe,0xb3,0xbf,
		0xbc,0x9a,0x9c,0x9e,0x9d,0x3f,0xa2,0x9f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0xa5,0xb4,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
	};
	static unsigned char cp_utf8_to_1251_page_20[256] = {
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x96,0x97,0x3f,0x3f,0x3f,
		0x91,0x92,0x82,0x3f,0x93,0x94,0x84,0x3f,
		0x86,0x87,0x95,0x3f,0x3f,0x3f,0x85,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x89,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x8b,0x9b,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x88,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
	};
	static unsigned char cp_utf8_to_1251_page_21[256] = {
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0xb9,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x99,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
		0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
	};

	int ucode_to_cp1251(const wchar_t *src, char *dest, unsigned maxchars)
	{
		unsigned i;
		for (i = 0; *src && i < maxchars; i++)
		{
			switch (src[i] & 0xff00) {
			case 0x0000:
				dest[i] = cp_utf8_to_1251_page_00[src[i] & 0xff];
				break;
			case 0x0400:
				dest[i] = cp_utf8_to_1251_page_04[src[i] & 0xff];
				break;
			case 0x2000:
				dest[i] = cp_utf8_to_1251_page_20[src[i] & 0xff];
				break;
			case 0x2100:
				dest[i] = cp_utf8_to_1251_page_21[src[i] & 0xff];
				break;
			default:
				dest[i] = '?';
			}
		}
		if (i < maxchars && 0 != dest[i])
		{
			dest[i++] = 0;
		}
		return i;
	}

	int64_t wtoi(const wchar_t* s)
	{
		static const wchar_t digits[] = L"0123456789";  /* legal digits in order */
		uint64_t val = 0;         /* value we're accumulating */
		int neg = 0;              /* set to true if we see a minus sign */

		/* skip whitespace */
		while (*s == L' ' || *s == L'\t')
			s++;

		/* check for sign */
		if (*s == L'-') {
			neg = 1;
			s++;
		}
		else if (*s == L'+')
			s++;

		/* process each digit */
		while (*s) {
			const wchar_t* where;
			int64_t digit;

			/* look for the digit in the list of digits */
			where = wcschr(digits, *s);
			if (where == NULL)
				break;
			digit = (where - digits);
			val = val * 10 + digit;
			s++;
		}

		if (neg)
			return -1 * val;
		return val;
	}
	int64_t escape_sql_literal(const wchar_t* str, wchar_t* result, size_t& result_len)
	{
		if (0 == result_len)
			return 0;
		int64_t max_res_len = result_len - 1;
		wchar_t* ptr = result;
		for (/* no init*/; '\0' != str[0] && (ptr - result) < max_res_len; str++)
		{
			switch (*str)
			{
			case L'\\':
				*ptr++ = '\\';
				*ptr++ = '\\';
				break;
			case L'\n':
				*ptr++ = '\\';
				*ptr++ = 'n';
				break;
			case L'\r':
				*ptr++ = '\\';
				*ptr++ = 'r';
				break;
			case '\7':
				*ptr++ = '\\';
				*ptr++ = '7';
				break;
			case '\b':
				*ptr++ = '\\';
				*ptr++ = 'b';
				break;
			case '\f':
				*ptr++ = '\\';
				*ptr++ = 'f';
				break;
			case '\t':
				*ptr++ = '\\';
				*ptr++ = 't';
				break;
			case '\v':
				*ptr++ = '\\';
				*ptr++ = 'v';
				break;
			case '\'':
				*ptr++ = '\'';
				*ptr++ = '\'';
				break;
			case '\"':
				*ptr++ = '\\';
				*ptr++ = '\"';
				break;
			default:
				*ptr++ = *str;
			}
		}
		*ptr = 0;
		return (ptr - result);
	}


	int64_t escape_json_literal(const wchar_t* str, wchar_t* result, size_t& result_len)
	{
		if (0 == result_len)
			return 0;
		int64_t max_res_len = result_len - 1;
		wchar_t* ptr = result;
		for (/* no init*/; '\0' != str[0] && (ptr - result) < max_res_len; str++)
		{
			switch (*str)
			{
			case '\b':
				*ptr++ = '\\';
				*ptr++ = 'b';
				break;
			case '\f':
				*ptr++ = '\\';
				*ptr++ = 'f';
				break;
			case L'\n':
				*ptr++ = '\\';
				*ptr++ = 'n';
				break;
			case L'\r':
				*ptr++ = '\\';
				*ptr++ = 'r';
				break;
			case '\t':
				*ptr++ = '\\';
				*ptr++ = 't';
				break;
			case '\"':
				*ptr++ = '\\';
				*ptr++ = '\"';
				break;
			case L'\\':
				*ptr++ = '\\';
				*ptr++ = '\\';
				break;
			default:
				*ptr++ = *str;
			}
		}
		*ptr = 0;
		return (ptr - result);
	}

	/*
	* Standard C function: parse a string that represents a decimal integer.
	* Leading whitespace is allowed. Trailing gunk is allowed too. Doesn't
	* really report syntax errors in any useful way.
	*/

	int64_t
		__wtoi64(const wchar_t* s)
	{
		static const wchar_t digits[] = L"0123456789";  /* legal digits in order */
		uint64_t val = 0;         /* value we're accumulating */
		int neg = 1;              /* set to true if we see a minus sign */

								  /* skip whitespace */
		while (*s == L' ' || *s == L'\t')
			s++;

		/* check for sign */
		if (*s == L'-') {
			neg = -1;
			s++;
		}
		else if (*s == L'+')
			s++;

		/* process each digit */
		while (*s) {
			const wchar_t* where;
			int64_t digit;

			/* look for the digit in the list of digits */
			where = wcschr(digits, *s);
			if (where == NULL)
				break;
			digit = (where - digits);
			val = val * 10 + digit;
			s++;
		}

		return neg * (int64_t)val;
	}

	int64_t
		__str2i64(const char* s, unsigned base)
	{
		static const char digits[] = "0123456789ABCDEF";  /* legal digits in order */
		uint64_t val = 0;         /* value we're accumulating */
		int neg = 1;              /* set to true if we see a minus sign */

		assert(base > 0 && base <= 16);
		if (base == 0 || base > 16)
			return 0;
		/* skip whitespace */
		while (*s == ' ' || *s == '\t')
			s++;

		/* check for sign */
		if (*s == '-') {
			neg = -1;
			s++;
		}
		else if (*s == '+')
			s++;

		/* process each digit */
		while (*s) {
			const char* where;
			int64_t digit;

			/* look for the digit in the list of digits */
			where = strchr(digits, toupper(*s));
			if (where == NULL)
				break;
			digit = (where - digits);
			val = val * base + digit;
			s++;
		}

		return neg * (int64_t)val;
	}



	thread_local char* throw_buf = NULL;
	const int throw_buf_size = 1023;
	void fthrow_(const char* fmt, ...)
	{
		assert(fmt);
		if (NULL == throw_buf)
			throw_buf = new char[throw_buf_size + 1];

		va_list args;
		va_start(args, fmt);
		int write_size = ::vsnprintf(throw_buf, throw_buf_size, fmt, args);
		if (write_size < 0)
			throw fmt;
		throw_buf[write_size] = '\0';
		va_end(args);
		throw (throw_buf);
	}

